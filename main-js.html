<script>
  // URL to the JSON data of the Google Spreadsheet
  // let gsheet_url = "https://spreadsheets.google.com/feeds/list/1eNmGC4mZpIGx9vyL_Y0m0wEvsnlREGYoj04LH9atoTg/1/public/values?alt=json";
  
  // Global variables to hold the data from the spreadsheet
  let quoteList = [];
  let authorList = [];
  let tagList = [];
  let caseList = [];
  let caseHeaderList = [];
  let prioList = [];
  let filteredPrioList = [];
  let prioHeaderList = [];
  
  const durationTypes = {
    short: 20000,
    regular: 40000,
    long: 60000
  }

  const { serverFunctions } = new Server();

  // Load data when the page is ready
  let app = new Vue({
    el: '#app',
    data () {
      return {
        info: null
      }
    }
  });

  let example2 = new Vue({
    el: '#example-2',
    data: {
      name: 'Vue.js',
      unassignedCasesList: [],
      isHidden: true
    },
    methods: {
      greet: function (event) {
        console.log('event',prioTable)
        prioTable.greet()
        prioTable.prio = prioList
      }
    },
    created() {
      console.log('test')
    }
  })

  

  // Table
  let table = new Vue({
    el: '#monitoringCasesTable',
    data: {
      cases: [],
      casesHeader: [],
      highlightedElements: [6],
      optionalElements: [0,1,7,8,9],
      prefixURL: 'https://cases.connect.corp.google.com/#/case/',
      intervalID: ''
    },
    computed: {
      // classObject: function w(k) {
      //   return {

      //   }
      // }
    },
    mounted() {
      this.renderTableData()
      this.recurringRender()
    },
    methods: {
      renderTableData: function() {
        google.script.run.withSuccessHandler(data => {
          let parsedCases = JSON.parse(data).cases

          // caseList = parsedCases.reverse()
          caseList = parsedCases
          caseHeaderList = Object.keys(caseList[0])

          // console.log(caseList.length,caseHeaderList)

          this.cases = caseList
          this.casesHeader = caseHeaderList
          lastUpdatedDate.updateDisplay()

        }).getMonitoringLogsData()
      },
      recurringRender: function() {
        this.intervalID = setInterval(this.renderTableData, 20000)
      }
    }
  });


  // Expiring Table
  let expiringTable = new Vue({
    el: '#expiringCasesTable',
    data: {
      cases: [],
      filteredCases: [],
      casesHeader: [],
      highlightedElements: [6],
      optionalElements: [0,1,7,8,9],
      prefixURL: 'https://cases.connect.corp.google.com/#/case/',
      intervalID: ''
    },
    computed: {
      // classObject: function w(k) {
      //   return {

      //   }
      // }
    },
    mounted() {
      this.renderTableData()
      this.recurringRender()
    },
    methods: {
      renderTableData: function() {
        google.script.run.withSuccessHandler(data => {
          let parsedCases = JSON.parse(data).cases

          caseList = parsedCases.reverse()
          caseHeaderList = Object.keys(caseList[0])

          // console.log(caseList.length,caseList)
          this.filteredCases = caseList.filter(c => c.Status == 'Processing' || c.Status == '')
          this.cases = caseList
          this.casesHeader = caseHeaderList
          lastUpdatedDate.updateDisplay()

        }).getMonitoringLogsData()
      },
      recurringRender: function() {
        this.intervalID = setInterval(this.renderTableData, 20000)
      }
    }
  });

  let filterButtons = new Vue({
    el: '#filterStatusBtn',
    methods: {
      greet: function(event) {
        console.log('clicked:',event.target)
        console.log(prioTable, prioTable.prio)
        prioTable.toggleShit()
      }
    }
  });

  let reshuffleButton = new Vue({
    el: '#reshuffleButton',
    methods: {
      greet: function(event) {
        console.log('clicked:',event.target)
        console.log(prioTable, prioTable.prio)
        prioTable.toggleShit()
      },
      doReshuffle: function() {
        Swal.fire({
          title: 'Go get something',
          showCancelButton: true,
          confirmButtonText: 'Look up',
          showLoaderOnConfirm: true,
          preConfirm: (login) => {
            return serverFunctions
                .getUnprocessedCases()
                .then(data => {
                    const { unassignedCases } = JSON.parse(data);
                    this.unassignedCasesList = unassignedCases
                    console.log(data, unassignedCases)
                    
                    return unassignedCases
                })
                .catch(error => {
                    Swal.showValidationMessage(
                      `Request failed: ${error}`
                    )
                })
          },
          allowOutsideClick: () => !Swal.isLoading()
        })
        .then(({ 'value':assignedCases }) => {
          if (!assignedCases.length) Swal.fire(
            {icon: 'error', title: 'No assigned cases found'}
          )
          console.log(assignedCases)
          const parsedAssignedCases = JSON.stringify(assignedCases)
          const caseIDArray = assignedCases
            .map(e => e["caseIDArray"]).flat();
          const parsedCaseIDs = JSON.stringify(caseIDArray)
          console.log(caseIDArray)

          Swal.fire({
            title: 'All done!',
            html: `
              Assigned cases:
              <ul class="collection">
                ${assignedCases
                .map(c => {
                  return `
                    <li class="collection-item">
                    ${c.ldap} : ${c.assignedCases}
                    </li>
                  `
                })
                .join('')}
              </ul>
            `,
            confirmButtonText: 'Undo Assignment!',
            showLoaderOnConfirm: true,
            allowOutsideClick: () => !Swal.isLoading(),
            preConfirm: () => {
              serverFunctions
                .doDeductPrio(parsedAssignedCases)
                .then(response => {
                  let { message,operationCode,newValue } = JSON.parse(response);
                  console.log(message,operationCode,newValue)
                })
                .catch(error => {
                  console.log('ERROR',error)
                  Swal.showValidationMessage(
                    `Request failed: ${error}`
                  )
                })

              return serverFunctions
                .doDeleteLDAPAssignment(parsedCaseIDs)
                .then(response => {
                  let { message,operationCode,newValue } = JSON.parse(response);
                  console.log(message,operationCode,newValue)

                  if (operationCode == 202){
                    return serverFunctions
                      .autoAssignCases()
                      .then(response => {
                        let { message,operationCode,newValue } = JSON.parse(response);
                        console.log(message,operationCode,newValue)
                        operationCode == 202 ? Swal.fire({icon: 'success', title: message}) : ''
                      })
                  }
                })
                .catch(error => {
                  console.log('ERROR',error)
                  Swal.showValidationMessage(
                    `Request failed: ${error}`
                  )
                })
            }
          })
        })
      }
    }
  });

  //prioUpdateSelect
  let prioDurationSelect = new Vue({
    el: '#prioDurationSelect',
    methods: {
      intervalChanged: function(event) {
        const { 'target':elem } = event;
        const selectedValue = elem.options[elem.selectedIndex].value;        
        if (durationTypes.hasOwnProperty(selectedValue)) {
          prioTable.refreshInterval = durationTypes[selectedValue]
          clearInterval(prioTable.intervalID)
          prioTable.recurringRender()
        }
      }
    }
  });

  // prioConfigBtn
  let prioConfigBtn = new Vue({
    el: '#prioConfigBtn',
    created: function() {
      // Initialize Materialize Modals
      const modalElems = document.querySelectorAll('.modal');
      const modalInstances = M.Modal.init(modalElems, {});
    },
    methods: {
      togglePrioConfig: function(event) {
        // console.log(event.currentTarget)
      }
    }
  });
  const skipTimepicker = new Vue({
    el: '#skipTimepicker',
    mounted: function() {
      // Initialize Time Picker
      const timepickerElem = document.querySelector('#skipTimepicker');
      const timepickerInstance = M.Timepicker.init(timepickerElem, {
        twelveHour: false
      });
    },
    methods: {
      changedTime: function(event) {
        const { currentTarget } = event;
        const instance = M.Timepicker.getInstance(currentTarget);
        skippedInput.skippedComputedValue = event.currentTarget.value
      }
    }
  });

  const skippedInput = new Vue({
    el: '#skippedInput',
    data: {
      skippedComputedValue: ''
    },
    mounted: function() {
    },
    methods: {
    },
    computed: {
      deductedSkippedTime: function(e) {
        const [ time, multiplier ] = this.skippedComputedValue.split(' ');
        const [ hours, minutes ] = time.split(':')
        const timeSubtractor = (h,m) => {
          const parsedHour = parseInt(h);
          const parsedMin = parseInt(m);
          const calculated = ( ( ( (parsedHour * 60) + parsedMin) - 5) / 60);
          const hour = Math.floor(calculated)
          const min = Math.floor(Math.round((calculated % 1) * 60))
          console.log({calculated},{hour},{min})
          return `${hour}:${min}`
        }

        return timeSubtractor(hours,minutes)      
      }
    }
  })

  const ldapTextarea = new Vue({
    el: '#ldapTextarea',
    data: {
      textAreaValues: this.value
    }
  })

  const autoskipSubmitBtn = new Vue({
    el: '#autoskipSubmitBtn',
    data: {},
    methods: {
      doSkip: async function(e) {
        const { textAreaValues } = ldapTextarea;
        const { selectedValues, updateStatusByShift } = skipMultipleSelect;
        
        if(selectedValues.length != 0){
          await updateStatusByShift(selectedValues)
        } else {
          // await 
        }

        this.doClearValues()
      },
      doClearValues: function() {
        console.log('CLEARING SHIT!')
        ldapTextarea.textAreaValues = ""
        M.FormSelect.init(skipMultipleSelect,{})
        console.log(ldapTextarea.textAreaValues, skipMultipleSelect.selectedIndex)
      }
    }
  })

  const skipMultipleSelect = new Vue({
    el: '#skipMultipleSelect',
    data: {
      selectedValues: ''
    },
    mounted: function() {
    },
    methods: {
      selectedValueChanged: function(e) {
        const instance = M.FormSelect.getInstance(e.currentTarget);
        const shifts = instance.getSelectedValues()

        this.selectedValues = shifts;

        console.log({shifts})
      },
      updateStatusByShift: async function(shiftArray) {
        if (!shiftArray.length) return

        const { prio } = await this.getPrioData();

        const filteredPrioData = prio.filter(({ LDAP,Shift }) => {
          return shiftArray.includes(Shift)
        });
        const filteredLDAP = filteredPrioData.map(({ LDAP }) => LDAP);
        
        ldapTextarea.textAreaValues = filteredLDAP.toString();
        // Updates all ldaps by shift
        filteredLDAP.forEach(ldap => {
          let request = {
            id: ldap,
            action: 'SKIP'
          }
          this.updateStatus(JSON.stringify(request))
        })
        
        
        console.log({filteredPrioData})
          
      },
      updateStatus: function(requestObject) {
        if (!requestObject && JSON.parse(requestObject).length == 0) return
        return serverFunctions
          .doUpdateStatus(requestObject)
          .then(data => console.log(JSON.parse(data)))
          .catch(error => {
              console.log('Error:',error)
              Swal.showValidationMessage(
                `Request failed: ${error}`
              )
          })
      },
      getPrioData: function() {
        return serverFunctions
          .getPrioData()
          .then(data => JSON.parse(data))
          .catch(error => {
              console.log('Error:',error)
              Swal.showValidationMessage(
                `Request failed: ${error}`
              )
          })
      },
      getLDAPIndex: function(LDAP) {
        return serverFunctions
          .doFindLDAPPosition(LDAP)
          .then(data => {
            const { rowNumber } = JSON.parse(data);
            return rowNumber
          })
          .catch(error => {
              console.log('Error:',error)
              Swal.showValidationMessage(
                `Request failed: ${error}`
              )
          })
      }

    },
    computed: {
      deductedSkippedTime: function(e) {
        const [ time, multiplier ] = this.skippedComputedValue.split(' ');
        const [ hours, minutes ] = time.split(':')
        const timeSubtractor = (h,m) => {
          const parsedHour = parseInt(h);
          const parsedMin = parseInt(m);
          const calculated = ( ( ( (parsedHour * 60) + parsedMin) - 5) / 60);
          const hour = Math.floor(calculated)
          const min = Math.floor(Math.round((calculated % 1) * 60))
          console.log({calculated},{hour},{min})
          return `${hour}:${min}`
        }

        return timeSubtractor(hours,minutes)      
      }
    }
  })
  

  // prioTable
  let prioTable = new Vue({
    el: '#prioTable',
    data: {
      prio: [],
      filteredPrio: [],
      prioHeader: [],
      highlightedElements: [6],
      optionalElements: [0,1,7,8,9],
      intervalID: '',
      isHidden: true,
      refreshInterval: 60000
    },
    mounted() {
      this.renderTableData()
      this.recurringRender()
    },
    created: function() {
      console.log('CREATED!')
    },
    methods: {
      renderTableData: function() {
        google.script.run.withSuccessHandler(data => {
          let parsedPrio = JSON.parse(data).prio
          
          // console.log(parsedPrio,Array.isArray(parsedPrio[0]))
          parsedPrio.sort((a,b) => a.MTD < b.MTD)

          prioList = parsedPrio
          filteredPrioList = prioList.filter(c => c.Status !== 'SKIP')
          prioHeaderList = Object.keys(prioList[0])
          

          this.prio = prioList
          this.filteredPrio = this.isHidden ? filteredPrioList : prioList
          this.prioHeader = prioHeaderList
          lastUpdatedDate.updateDisplay()
          this.initializeMaterialElements()

        }).getPrioData()
      },
      recurringRender: function() {
        this.intervalID = setInterval(this.renderTableData, this.refreshInterval)
      },
      toggleShit: function() {
        this.isHidden = !this.isHidden
        // this.filteredPrio = prioList
      },
      initializeMaterialElements: function() {
          let tooltipElems = document.querySelectorAll('.tooltipped');
          let tooltipInstances = M.Tooltip.init(tooltipElems, {});

          let selectElems = document.querySelectorAll('select:not(.swal2-select)');
          let selectInstances = M.FormSelect.init(selectElems, {});
      },
      changeStatus: function(e) {
        let requestObject;
        const button = e.currentTarget;
        const allButtons = button.parentElement.querySelectorAll('button');
        let { action,'rowid':id } = button.dataset;
        action = action !== 'CLEAR' ? action : '';
        // const action = button.dataset.action;
        // const id = button.dataset.rowid;
        
        console.log(button,action,id)

        // Toggle other buttons
        allButtons.forEach(button => button.classList.remove('disabled'))

        // Toggle button onclick
        button.classList.add('disabled');

        return serverFunctions
          .doUpdateStatus(JSON.stringify({ id, action }))
          .then(data => {
            console.log(data)
            M.toast({html: 'Successfully updated!'})
          })
          .catch(error => {
              Swal.showValidationMessage(
                `Request failed: ${error}`
              )
          })

      }
    },
    watch: {
      isHidden: function(val) {
        val ? this.filteredPrio = filteredPrioList : this.filteredPrio = prioList
      },
      refreshInterval: function(val) {
        val ? this.refreshInterval = this.refreshInterval : console.log('not changed:',this.refreshInterval)
      }
    }
  });


  // Search bar
  let search = new Vue({
    el: '#search',
    methods: {
      filterQuotes: function(event) {
        let query = event.target.value;

        // Reset filter if query is empty string
        if (query.length == 0) {
          table.cases = caseList;
        }

        // Do nothing if query is too short
        if (query.length < 3) return;
        
        let filtered = [];
        query = query.toLowerCase();
        console.log(query);

        // Search in quote, author and source
        caseList.forEach(function(value) {
          let { 
            'Study ID':studyID, 
            'Assigned To':ldap, 
            'Case ID':caseID
          } = value;
          studyID = studyID.toString();
          ldap = ldap.toLowerCase();
          caseID = caseID.toLowerCase();
          if (
            (studyID.search(query) >= 0) ||
            (ldap.search(query) >= 0) ||
            (caseID.search(query) >= 0)) {
            filtered.push(value);
          }
        });
        table.cases = filtered;
      }
    }
  });

  let lastUpdatedDate = new Vue({
    el: '#lastUpdated',
    data: {
      dateObject: new Date().toLocaleTimeString()
    },
    created () {
      this.updateDisplay()
    },
    methods: {
      updateDisplay: function() {
        this.dateObject = new Date().toLocaleTimeString()
      },
      showStatusButtons: function() {
        prioTable.isActive = !prioTable.isActive
        console.log('status button clicked!', prioTable.isActive)
      }
    }
  });

  let toggleDarkModeBtn = new Vue({
    el: '#toggleDarkModeBtn',
    methods: {
      toggleDarkMode: function(e) {
        console.log(e.currentTarget)
        document.body.classList.toggle('dark-body', 'white-text');
      }
    }   
  });

  let refreshTableBtn = new Vue({
    el: '#refreshTableBtn',
    methods: {
      refreshTableDate: function(event) {
        console.log('clicked:',event.target)
        table.renderTableData()
        expiringTable.renderTableData()
      }
    }
  });

  // let quotes = new Vue({
  //   el: '#quotes',
  //   data: {
  //     quotes: quoteList
  //   }
  // });

  let authors = new Vue({
    el: '#authors',
    data: {
      authors: authorList,
      isActive: false
      
    },
    methods: {
      selectAuthor: function(event) {
        let selectedLI = event.currentTarget;
        let selectedUL = event.currentTarget.parentElement;
        let allLI = Array.from(selectedUL.children);

        
        console.log(selectedLI)
        if (!selectedLI.classList.contains('active')){
          allLI.forEach(li => li.classList.remove('active'))
          selectedLI.classList.add('active')
          let selected = [];
          let author = event.target.getAttribute('data');
          quoteList.forEach(function(value) {
            if (value.author == author) {
              selected.push(value);
            }
          });
          quotes.quotes = selected;

          
        } else {
          allLI.forEach(li => li.classList.remove('active'))
          authors.reset()
        }        
      },
      reset: function(event) {
        quotes.quotes = quoteList;
      }
    }
  });

  let resetFilter = new Vue({
    el: '#reset-filter',
    methods: {
      reset: function(event) {
        quotes.quotes = quoteList;
      }
    }
  });

  let tags = new Vue({
    el: '#tags',
    data: {
      tags: tagList
    },
    methods: {
      selectTag: function(event) {
        let selected = [];
        let tag = event.target.getAttribute('data');
        quoteList.forEach(function(value) {
          if (value.tags.includes(tag)) {
            selected.push(value);
          }
        });
        quotes.quotes = selected;
      }
    }
  });

  function parseData(entries) {
    
    let authorSet = new Set();
    let tagSet = new Set();

    entries.forEach(function(value) {
      let entry = {
        "quote": value.gsx$quote.$t,
        "author": value.gsx$author.$t,
        "source": value.gsx$source.$t,
        "tags": value.gsx$tags.$t.split(",")
      };
      authorSet.add(entry.author);

      entry.tags.forEach(function(t) {
        tagSet.add(t);
      });

      quoteList.push(entry);
    });
    authorList = Array.from(authorSet);
    authorList.sort();

    tagList = Array.from(tagSet);
    tagList.sort();

    quotes.quotes = quoteList;
    authors.authors = authorList;
    tags.tags = tagList;
  }

</script>